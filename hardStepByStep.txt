1. First, figure out what we are dealing with. Throwing this right into a disassembler could work, but that is not what we would want to do. A good way to figure out information about a file is to use the "file" command in Linux, the "strings" command in linux, or opening the compiled binary in a text file to maybe get some strings out of it. From any of these, we would find that this is infact a GOlang binary.
2. Knowing that this is a GOlang binary, looking up on how to reverse GOlang binaries gives you links to scripts to input into Ghidra. We will need these. The first result on google, https://github.com/mooncat-greenpy/Ghidra_GolangAnalyzerExtension is what I used. 
3. Inputting this into Ghidra, the file is analyzed much better than what it would look like without the extension. We can read the names of the files, euereka!
4. Once the analyzing has been done by Ghirda, look into the Functions that ghidra finds, specifically all functions that start with "M" because that is where we will find the main function
5. Inside the main function we read a call to the "printFlag" function, checking out that one shows us that we try to print out some data, but there's no clear variable or data in this function. So where do we find it?
6. There is one more function call, whose name is not constant throughout decompiling, that stands out inside the printFlag function. It clearly is setting up some sort of data buffer for variables we later call in our print. Following it takes us to a function that reads data stored in the file. The data is stored in hex, but if we combine it all together, we get our flag!

cdctf{Ry4nW1lLiams_is_17}
